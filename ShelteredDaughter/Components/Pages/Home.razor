@page "/"
@using ShelteredDaughter.Models
@implements IDisposable

<PageTitle>Sheltered Daughter</PageTitle>

<header>
    <h1 class="title">箱入り娘(大家族)</h1>
    <p class="subtitle">「娘だけ」を玄関から出してね！</p>
</header>

<div class="status">
    @if (isCleared)
    {
        <span id="elapsed-time">🎉クリア🎉</span>
    }
    <span id="elapsed-time">経過時間: @Elapsed 秒</span>
    <button id="reset-btn" @onclick="ResetGame">リセット</button>
</div>

@* --------------------------------------------------------
   駒の移動（マウス操作やタッチ操作）時に、ポインタが駒から外れても
   追随するために盤面で移動イベントを管理 
   -------------------------------------------------------- *@
<div class="game-container"
     @onmousemove="OnMouseMove"
     @onmouseup="EndDrag"
     @ontouchmove="OnTouchMove"
     @ontouchend="EndDrag">

    <div class="board" style="--rows:@Rows; --cols:@Cols; position:relative;">
        @* 盤面セル *@
        @for (int y = 0; y < Rows; y++)
        {
            for (int x = 0; x < Cols; x++)
            {
                int cell = Board[y, x];
                <div class="cell @(cell==1 ? "wall" : cell==9 ? "exit" : "empty")"
                     style="grid-column:@(x+1); grid-row:@(y+1);">
                    @(cell == 9 ? "玄関" : "")
                </div>
            }
        }

        @* 駒（absolute配置） *@
        @foreach (var p in Pieces)
        {
            <div class="piece @(p.ColorClass) @(Selected == p ? "selected" : "")"
                 style="
                    position:absolute;
                    left:@(p.X * 50)px;
                    top:@(p.Y * 50)px;
                    width:@(p.Width * 50)px;
                    height:@(p.Height * 50)px;"
                 @onclick="() => SelectPiece(p)"
                 @onmousedown="(e) => StartDrag(p, e.ClientX, e.ClientY)"
                 @ontouchstart="(e) => {
                     if (e.Touches.Length > 0) {
                         var t = e.Touches[0];
                         StartDrag(p, t.ClientX, t.ClientY);
                     }
                 }">
                @p.Name
            </div>
        }
    </div>

</div>

@if (!string.IsNullOrEmpty(Message))
{
    <div class="clear-message">@Message</div>
}

<footer class="footer">
    提供：ハカマタソフト X
    <a href="https://x.com/masayahak_dev" target="_blank">@@masayahak_dev</a>
</footer>


@code {

    // 盤面の定義
    private int[,] Board = new int[8, 8]
    {
        // 盤面定義 (0=空, 1=壁, 9=出口)
        {1,1,1,1,1,1,1,1},
        {1,0,0,0,0,0,0,1},
        {1,0,0,0,0,0,0,1},
        {1,0,0,0,0,0,0,1},
        {1,0,0,0,0,0,0,1},
        {1,0,0,0,0,0,0,1},
        {1,1,1,9,9,1,1,1},
        {1,1,1,9,9,1,1,1},
    };
    private int Rows => Board.GetLength(0);
    private int Cols => Board.GetLength(1);

    // 駒の定義
    private List<Piece> Pieces = new();
    private void InitPieces()
    {
        Pieces.Clear();
        // 駒名、駒の左上のX座標、Y座標、幅、高さ、色のクラス名
        Pieces.Add(new Piece("父",   2, 1, 1, 2, "Color_父"));
        Pieces.Add(new Piece("娘",   3, 1, 2, 2, "Color_娘"));
        Pieces.Add(new Piece("母",   5, 1, 1, 2, "Color_母"));
        Pieces.Add(new Piece("手代", 1, 3, 1, 1, "Color_手代"));
        Pieces.Add(new Piece("大番頭",2, 3, 4, 1, "Color_大番頭"));
        Pieces.Add(new Piece("兄嫁", 6, 3, 1, 1, "Color_兄嫁"));
        Pieces.Add(new Piece("丁稚", 1, 4, 1, 1, "Color_丁稚"));
        Pieces.Add(new Piece("女中", 2, 4, 2, 1, "Color_女中"));
        Pieces.Add(new Piece("番頭", 4, 4, 2, 1, "Color_番頭"));
        Pieces.Add(new Piece("丁稚", 6, 4, 1, 1, "Color_丁稚"));
        Pieces.Add(new Piece("番犬", 1, 5, 1, 1, "Color_番犬"));
        Pieces.Add(new Piece("祖父", 2, 5, 2, 1, "Color_祖父"));
        Pieces.Add(new Piece("祖母", 4, 5, 2, 1, "Color_祖母"));
        Pieces.Add(new Piece("丁稚", 6, 5, 1, 1, "Color_丁稚"));
    }


    //------------------------------------------------
    // 初期処理
    //------------------------------------------------
    protected override void OnInitialized()
    {
        StartTimer();
        InitPieces();
    }

    // タイマー
    private System.Threading.Timer? timer;
    private int Elapsed = 0;
    private string Message = "";
    private bool isCleared = false;

    private void StartTimer()
    {
        timer?.Dispose();
        timer = new System.Threading.Timer(_ =>
        {
            InvokeAsync(() =>
            {
                Elapsed++;
                StateHasChanged();
            });
        }, null, 1000, 1000);
    }

    private void ResetGame()
    {
        Elapsed = 0;
        isCleared = false;
        Message = "";
        InitPieces();
        StartTimer();
        StateHasChanged();
    }

    public void Dispose()
    {
        timer?.Dispose();
    }

    //------------------------------------------------
    // 駒の選択と制御
    //------------------------------------------------

    // 駒の選択
    private Piece? Selected;
    private void SelectPiece(Piece p) => Selected = p;

    // ドラッグ操作
    private Piece? draggingPiece;
    private int startX, startY;

    private void StartDrag(Piece p, double clientX, double clientY)
    {
        Selected = p;
        draggingPiece = p;
        startX = (int)clientX;
        startY = (int)clientY;
    }

    private void OnMouseMove(MouseEventArgs e)
    {
        if (draggingPiece == null) return;
        HandleDrag((int)e.ClientX, (int)e.ClientY);
    }

    private void OnTouchMove(TouchEventArgs e)
    {
        if (draggingPiece == null || e.Touches.Length == 0) return;
        var touch = e.Touches[0];
        HandleDrag((int)touch.ClientX, (int)touch.ClientY);
    }

    private void HandleDrag(int currentX, int currentY)
    {
        // ドラッグして一定距離以上動かしたら、動かしたとみなす。
        int dx = 0, dy = 0;
        if (Math.Abs(currentX - startX) > 25)
        {
            dx = (currentX > startX) ? 1 : -1;
            startX = currentX;
        }
        if (Math.Abs(currentY - startY) > 25)
        {
            dy = (currentY > startY) ? 1 : -1;
            startY = currentY;
        }
        if (dx != 0 || dy != 0)
            MoveSelected(dx, dy);
    }

    private void EndDrag()
    {
        draggingPiece = null;
    }

    // 移動処理
    private void MoveSelected(int dx, int dy)
    {
        if (Selected == null) return;

        if (!isCleared) Message = "";

        int newX = Selected.X + dx;
        int newY = Selected.Y + dy;

        if (CanMove(Selected, newX, newY))
        {
            Selected.X = newX;
            Selected.Y = newY;
        }
    }

    //------------------------------------------------
    // 移動して良いか判定する
    //------------------------------------------------
    private bool CanMove(Piece p, int newX, int newY)
    {
        // ----- 盤外は禁止 -----
        if (newX < 0 || newX + p.Width > Cols) return false;
        if (newY < 0 || newY + p.Height > Rows) return false;

        // ----- 壁セルとの衝突 -----
        bool blocked = Enumerable.Range(newY, p.Height).Any(yy =>
            Enumerable.Range(newX, p.Width).Any(xx =>
                Board[yy, xx] == 1));
        if (blocked) return false;

        // 出口判定（娘だけOK）
        bool inExit = Enumerable.Range(newY, p.Height).Any(yy =>
            Enumerable.Range(newX, p.Width).Any(xx =>
                Board[yy, xx] == 9));
        if (inExit)
        {
            if (p.Name == "娘")
            {
                Clear();
                return true;
            }
            else
            {
                Message = "玄関を出てよいのは娘だけ";
                return false;
            }
        }

        // 他駒との衝突
        foreach (var o in Pieces.Where(o => o != p))
        {
            bool overlapX = newX < o.X + o.Width && newX + p.Width > o.X;
            bool overlapY = newY < o.Y + o.Height && newY + p.Height > o.Y;
            if (overlapX && overlapY) return false;
        }

        return true;
    }

    private void Clear()
    {
        Message = "🎉クリア🎉";
        isCleared = true;
        timer?.Dispose();
        timer = null;
        StateHasChanged();
    }

}
